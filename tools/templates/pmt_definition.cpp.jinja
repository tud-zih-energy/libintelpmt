#include <libintelpmt/pmt_{{uniqueid}}.hpp>

#include <array>

namespace intelpmt
{


{% for transformation in transformations %}
static double calc_{{transformation['name']}}_{{uniqueid}}(DeviceInstance &device, uint64_t input1, uint64_t input2)
{
    uint64_t parameter_0 = device.read_sample(input1);
    {% if transformation['twoargs'] %}
    uint64_t parameter_1 = device.read_sample(input2);
    {% endif %}

    {% if transformation['type'] == 'float' %}
    double res = {{transformation['function']}};
    {% else %}
    uint64_t res = {{transformation['function']}};
{% endif %}
    return res;
}
{% endfor %}

{% for name, datatype in datatypes.items() %}
    {% if datatype['type'] == 'enum' %}
static const char *print_{{name}}_{{uniqueid}}(double value)
{
        {% for value in datatype['values'] %}
    {% if loop.first %} if {% else %} else if {% endif %} ( value == {{value[0]}})
    {
        return "{{value[1]}}";
    }
        {% endfor %}
    
    return "UNKNOWN";
}
    {% endif %}
{% endfor %}

static constexpr std::array<std::pair<const char *, uint64_t>, {{aggregators|length}}>  PMT_{{uniqueid}}_counter_names { { 
{% for aggregator in aggregators %}
        { "{{aggregator['name']}}", (uint64_t)PMT_{{uniqueid}}::CounterType::{{aggregator['type']}} } {% if not loop.last %}, {%endif%}

{% endfor %}
    } };

static constexpr std::array<std::pair<uint64_t, struct Sample>, {{samples|length}}> 
PMT_{{uniqueid}}_samples { {
{% for sample in samples %}
        { (uint64_t)PMT_{{uniqueid}}::SampleType::{{sample['name']}}, { {{sample['offset']}}, {{sample['size']}} } } {% if not loop.last %}, {%endif%}

{% endfor %}
 
 } };

static constexpr std::array<std::pair<uint64_t, struct Unit>, {{aggregators|length}}>
PMT_{{uniqueid}}_units { {
{% for aggregator in aggregators %}
        {  (uint64_t)PMT_{{uniqueid}}::CounterType::{{aggregator['type']}},
        {% if aggregator['datatype'] not in datatypes %}
            { "#", nullptr}
        {% else %}
            {% if datatypes[aggregator['datatype']]['type'] == 'enum' %}
                { "enum", print_{{aggregator['datatype']}}_{{uniqueid}} } 
            {% else %}
                {% if datatypes[aggregator['datatype']]['unit'] ==  None %}
                    { "#", nullptr }
                {% else %}
                    { "{{datatypes[aggregator['datatype']]['unit']}}", nullptr }             
                {% endif %}
            {% endif %}
        {% endif %}

        }{% if not loop.last %}, {% endif %}

{% endfor %}
} } ;

static constexpr std::array<std::pair<uint64_t, struct Counter>, {{aggregators|length}}> PMT_{{uniqueid}}_counters { {
    {% for aggregator in aggregators %}
    {  (uint64_t)PMT_{{uniqueid}}::CounterType::{{aggregator['type']}}, { calc_{{aggregator['function']}}_{{uniqueid}}, { 
    {% for input in aggregator['inputs'] %}
        (uint64_t)PMT_{{uniqueid}}::SampleType::{{input}} {% if not loop.last %}, {% endif %}

    {% endfor %}
    } } } {% if not loop.last %}, {% endif %}
    
{% endfor %}

    } };

PMT_{{uniqueid}}::PMT_{{uniqueid}}(std::filesystem::path path)
        : Device(path)
{
    uniqueid_ = 0x{{uniqueid}};
}

uint64_t PMT_{{uniqueid}}::get_counter_id_by_name(const std::string &name)
{
    for(const auto &counter : PMT_{{uniqueid}}_counter_names)
    {
        if(strcmp(name.c_str(), counter.first) == 0)
        {
            return counter.second;
        }
    }
    throw std::runtime_error("Unknown counter!");
}

const Counter& PMT_{{uniqueid}}::get_counter_by_id(uint64_t id)
{
    for(const auto &counter : PMT_{{uniqueid}}_counters)
    {
        if(counter.first == id)
        {
            return counter.second;
        }
    }
    throw std::runtime_error("Unknown Counter!");
}

const Sample& PMT_{{uniqueid}}::get_sample_by_id(uint64_t id)
{
    for(const auto &sample : PMT_{{uniqueid}}_samples)
    {
        if(sample.first == id)
        {
            return sample.second;
        }
    }

    throw std::runtime_error("Unknown Counter!");
}

const Unit& PMT_{{uniqueid}}::get_unit_by_id(uint64_t id)
{
    for(const auto& unit : PMT_{{uniqueid}}_units)
    {
        if(unit.first == id)
        {
            return unit.second;
        }
    }
    throw std::runtime_error("Unknwon Counter!");
}

std::vector <std::string> PMT_{{uniqueid}}::get_counters()
{
    std::vector <std::string> res;
    for(const auto& counter : PMT_{{uniqueid}}_counter_names)
    {
        res.emplace_back(counter.first);
    }
    return res;
}
}

